% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\ifrubric
\centerline{\Large CSU2510H Exam 1 Rubric -- Spring 2011}

\else
\centerline{\Large CSU2510H Exam 1 -- Spring 2011}

\vspace{0.5cm}

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{8cm}\sloppy
\begin{itemize}
\item You may use the usual primitives and expression forms of any of
  the \code{class} languages; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} for
  {\tt (check-expect {\slshape c e})} and $\lambda$ for
  \code{lambda} to save time writing.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item We expect data \emph{and} interface definitions
  (although interfaces may be defined in comments rather than
  with \code{define-interface}).

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can be thinking
about the harder problems in background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & 17\\ \hline
2 & & 18\\ \hline
3 & & 12\\ \hline
4 & & 21\\ \hline
5 & & 15\\ \hline
%Extra & & \\ \hline
{\bf Total} & & 83 \\ \hline
%{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{problem}\pts{19}

The Programming Research Lab has been acquiring some new decorative
objects, in the form of rectangles and rectangular solids.
Unfortunately, they've all come unpainted, and now the graduate
students have to paint them.  Dan has been trying to calculate how
much this will cost, and he's enlisted you to help.  

First, some basic facts.  Rectangles have an area which is the width
times height, and must be painted on both sides.  Rectangular solids
have a surface area which is the sum of the areas of all of the
sides, or $2 (w \cdot d + d \cdot h + w \cdot h)$. Red paint costs 2
dollars per square foot, and blue paint costs 5 dollars per square
foot.  
%
Each decorative object has a color, and the appropriate dimensions,
measured as an integer number of feet.  

Design a representation for these decorative objects, and implement
the {\tt expense} method.  You should use \emph{overriding} to avoid
repeating code---in particular, you should only have one version of
the {\tt expense} method.

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}

;; A Rect is (rect% Number Number)           [+1]
;; an implements
;; expense : -> Number                       [+2]
;; how much will it cost to paint this?
;; area : -> Number                          [+2]
;; how much surface area does this have
(define-class rect%
  (fields w h color)
  (define/public (expense)                   [+3]
    (cond [(string=? (field color) "blue") (* 5 (area))]
	  [else (* 2 (area))]))
  (define/public (area) (* (w) (h) 2)))      [+1]

(check-expect ((rect% 10 10 "blue") . area) 200)   [+2]
(check-expect ((rect% 10 10 "red") . expense) 400)

;; A 3DRect is (3drect% Number Number Number String) [+1]
;; and extends Rect                                  [+1]
(define-class 3drect%
  (super rect%)                                      [+1]
  (fields d)                                         [+1]
  ;; overriding
  (define/public (area)                              [+2]
    (* 2 (+ (* (w) (h))
	    (* (h) (d))
	    (* (w) (d))))))

(check-expect ((3drect% 3 10 10 "red") . area) 320)   [+2]
(check-expect ((3drect% 3 10 10 "blue") . expense) 1600)


\end{verbatim}
\end{solution}
\end{problem}
%\ifrubric\bigskip\else
\newpage
%\fi



% \newpage
\begin{problem}\pts{22}

Tobin-Hochstadt and Van Horn have both been traveling a lot recently,
so they've decided to develop software to manage their trips.  Since
they're busy with writing the exam, they've asked you to help them
out. 

Additionally, since they want their program to be as verbose as
possible, they've asked you to write it in Java.  

\begin{enumerate}
\item
Initially, they've settled on the following kinds of data to represent
trips.  A {\tt Trip} is either a {\tt PlaneFlight}, with an airline
and a distance (in miles), or a {\tt Connection}, composed of two trips.  

Write a data definition for trips, and implement the {\tt howLong}
method, which computes the total time of the trip (in minutes),
assuming that airplanes fly at 10 miles per minute.

\item
Van Horn has discovered that getting around New England is easier if
you take the train, even though it takes 2 minutes to go 1 mile.  Add a new representation for this new kind of
trip, which should have a distance and an indication of whether the trip
is on the Acela, in which case the train goes twice as fast (1 minute
per mile).

\item Tobin-Hochstadt also likes to take the train, but unfortunately,
  he's been taking the commuter rail instead, which goes as fast as
  regular trains but is always half an hour late.  Add to your data
  definition of trains a representation for commuter rail trips.  
\end{enumerate}

All of your implementations must, of course, support the {\tt howLong}
method.    

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
interface Trip {                       //[+1]
    // how many minutes will this trip take? 
    public Integer howLong();          //[+1]
}

class PlaneFlight implements Trip {      [+1]
    Integer miles;                       [+2]
    String airline;
    PlaneFlight(Integer m, String s)     [+1]
         { miles = m; airline = s; }   
    public Integer howLong()             [+1]
      { return miles/10; }
}

class Connection implements Trip {   [+1]
    Trip first;                      [+2]
    Trip second;
    Connection(Trip t1, Trip t2) { first = t1; second = t2; }   [+1]
    public Integer howLong() { return first.howLong() + second.howLong(); } [+2]
}

// part 2

class TrainTrip implements Trip {  [+1]
    Integer miles;                 [+1]
    Boolean acela;
    TrainTrip(Integer m, Boolean a) { miles = m; acela = a; } [+1]
    public Integer howLong() { 
	if (acela) {
	    return miles;           [+1]
	}
	else {
	    return miles * 2;       [+1]
	}
    }
}

// Two possible solutions for part 3

class CommuterRail extends TrainTrip {   [+1]
    CommuterRail(Integer m) { super(m,false); } [+1]
    public Integer howLong() {                [+2]
	return miles * 2 + 30; // or super() + 30
    }
}

// or 

class CommuterRail implements Trip {  [+1]
    Integer miles;
    CommuterRail(Integer m) { miles = m; }   [+1]
    public Integer howLong() { 
	return miles * 2 + 30;            [+2]
    }
}

\end{verbatim}
\end{solution}
\end{problem}
%\ifrubric\bigskip\else
\newpage
%\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{20}

Here are data, class, and interface definitions for Complex Numbers:

\begin{verbatim}
;; A Complex is (cplx% Number Number)
;; dist : -> Number
;; How far is this point from the origin.
;; =? : Complex -> Boolean     (short for "bounding-box-area")
;; Determine if this Complex is the same as the given one

(define-class cplx%
  (fields real imag)
  (define/public (dist)
    (sqrt (+ (sqr (real)) (sqr (imag)))))
  (define/public (=? that) 
    (and (= (real) (that . real))
         (= (imag) (that . img)))))

\end{verbatim}

\begin{enumerate}
\item Design a {\tt UPair} data definition for an unordered pair of
  {\tt Complex}, with an {\tt =?}  method.  Because these are
  unordered pairs, 

\begin{verbatim}
 ((upair% (cplx% 1 1) (cplx% 2 2)) . =?
  (upair% (cplx% 2 2) (cplx% 1 1)))
\end{verbatim}

should produce {\tt \#t}.

\item Revise your data, class, and interface definitions so that your
  unordered pairs can store any kind of data, not just {\tt Posn}s.

\item Since {\tt UPair} is unordered, switching the two components of
  a pair should produce a pair that's equal to the original one.
  Define a predicate that expresses this property, and use it to state
  two test cases.

\end{enumerate}




\begin{solution}
\begin{verbatim} 

;; Part 1
;; A UPair is (upair% Posn Posn) [+1]
(define-class upair%
  (fields left right)            [+1]
  ;; =? : UPair -> Boolean       [+1]
  ;; compare this with p         [+1]
  (define/public (=? p)          [+3]
    (or (and ((left)  . =? (p . left))
	     ((right) . =? (p . right)))
	(and ((left)  . =? (p . right))
	     ((right) . =? (p . left))))))

(define p1 (cplx% 1 2))
(define p2 (cplx% 2 1))
(define u1 (upair% p1 p2))
(define u2 (upair% p2 p1))
(define u3 (upair% p2 p2))
(check-expect (u1 . =? u2) true)             [+2]
(check-expect (u1 . =? u3) false)

;; Part 2
;; A [UPair X] is (upair% X X)               [+2]
;; where X implements                        [+2]
;; =? : X -> Boolean

;; for not changing the code                 [+1]

(define-class upair%
  (fields left right)
  ;; =? : UPair -> Boolean
  ;; compare this with p
  (define/public (=? p)
    (or (and ((left)  . =? (p . left))
	     ((right) . =? (p . right)))
	(and ((left)  . =? (p . right))
	     ((right) . =? (p . left))))))

(define p1 (cplx% 1 2))
(define p2 (cplx% 2 1))
(define u1 (upair% p1 p2))
(define u2 (upair% p2 p1))
(define u3 (upair% p2 p2))
(check-expect (u1 . =? u2) true)
(check-expect (u1 . =? u3) false)

;; Part 3

;; swap-prop : [UPair X] -> Boolean                [+1]
;; check if this pair is equal to itself when swapped
(define (swap-prop up)                             [+3]
  (up . =? (upair% (up . right) (up . left))))

(check-expect (swap-prop (upair% (cplx% 1 2) (cplx% 2 1))) true) [+2]
(check-expect (swap-prop (upair% (cplx% 1 1) (cplx% 1 1))) true)

\end{verbatim}
\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{12}

One perspective that unifies the paradigms of programming with
functions and programming with objects is to view a ``function'' as an
object that understands a method called \code{apply}.  With that in
mind, we can define an interface for functions-as-objects:

\begin{verbatim}
;; A [IFun X Y] implements:
;; apply : X -> Y
;; Apply this function to the given input.
\end{verbatim}

Here we are representing a \code{X -> Y} function as an object that
has an \code{apply} method that consumes an \code{X} and produces a
\code{Y}.

\begin{enumerate}
\item Design a class that wraps a real function with contract \code{(X
  -> Y)} to implement \code{[IFun X Y]}.

\item Using your wrapper class, construct the objects representing the
  ``add 1'' function and ``sub 1'' function.

\item Another useful operation on functions is composition.  Here is
  the interface for a \code{compose} method that composes two functions
  represented as objects:

\begin{verbatim}
;; [IFun X Y] also implements:
;; compose : [IFun Y Z] -> [IFun X Z]
;; Produce a function that applies this function to its input, 
;; then applies the given function to that result.
\end{verbatim}

For example, if \code{addone} and \code{subone} refer to the objects
you constructed in part 2, the following check should succeed:

\begin{verbatim}
(check-expect ((addone . compose subone) . apply 5) 5)
(check-expect ((addone . compose addone) . apply 5) 7)
\end{verbatim}

Implement the \code{compose} method for your wrapper class.
\end{enumerate}

\begin{solution}

\begin{verbatim}
;; Part 1 [5pt]
(define-class fun%
  (fields f)
  (define/public (apply x)
    ((field f) x)))

;; Part 2 [2pt]
(define addone (fun% add1))
(define subone (fun% sub1))

;; Part 3 [5pt]
(define-class fun%
  (fields f)
  (define/public (compose g)
    (fun% (lambda (x)
            (g . apply (apply x))))))
\end{verbatim}

\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{21}

The Northeastern University Registrar is instituting a new course
registration system, in which each student will wait in a ``Virtual
Line'' until every student ahead of them has registered.  A simple way
to represent a line (also known as a \emph{queue}) is by using a list.
But this representation makes it slow to add somebody to the end of
the line (or to take somebody off the front of the line, depending on
whether the front of the list represents the front or rear of the
line).  

In order to provide maximal waiting efficiency, you have been tasked
with implementing a representation that uses \emph{two} lists!  The
key idea of this fancy representation is that one list will represent
some portion of the front of the line, while the other will represent
the remainder of the line \emph{in reverse order}.  So if you're the
first element of the first list, you are at the head of the line.  On
the other hand, if you're the first element of the second list, you
are the very last person in line.
%
Here is the interface for queues:
\begin{verbatim}
;; A [IQ X] implements:
;;
;; head : -> X
;; Produce the element at the head of this queue.
;; Assume: this queue is not empty.
;;
;; deq : -> [IQ X]      (Short for "dequeue")
;; Produces a new queue like this queue, but without 
;; this queue's first element.
;; Assume: this queue is not empty.
;;
;; enq : X -> [IQ X]    (Short for "enqueue")
;; Produce new queue with given element added to the
;; END of this queue.
;;
;; emp? : -> Boolean
;; Is this queue empty?
\end{verbatim}

The \code{head} and \code{deq} operations require that the queue be
non-empty when they are used, but this can be assumed and these
operations do not need to check for an empty queue.

Further, the Registrar's office has just learned about
\emph{invariants}, and insists on maintaining the following invariant
about all of their queues:

\begin{quote}
  {\it if the front of the queue is empty, the whole queue must also be empty.}
\end{quote} 

\noindent
The Registrar's office has given you three tasks to prepare their
Virtual Line for its launch later this semester:

\begin{enumerate}
\item Design an implementation of the queue data structure to the Registrar's
  specifications.  You must maintain the invariant stated above, and
  you should take advantage of the invariant when implementing the
  operations.
\item Unfortunately, when testing the queue, the Registrar has
  discovered that some queues with the same elements in the same order
  can be represented in multiple ways.  Give an example of two
  different representations of the same queue.  Implement a
  \code{to-list} operation which produces a list of elements going in
  order from the front to the rear of the queue. In your tests, you
  should show how this addresses the problem.
\item The Registrar has a problem with careless data entry.  Design
  and implement a constructor for queues which, given two input lists
  of elements, ensures that the invariant is maintained.  
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; Part 1:
;; invariant: front is empty IFF queue is empty
;; A [Queue X] is (queue% [Listof X] [Listof X])           [1pt]
;; and implements [IQ X]

(define-class queue%                                       [1pt]
  (fields front back)
  ;; Add element to the back
  ;; X -> [Queue X]
  ;; add it to the front IFF the front is empty
  ;; (otherwise invariant is violated)
  (check-expect (eq . enqueue 1) (queue% '(1) '()))        [1pt]
  (check-expect (q . enqueue 5) (queue% '(1 2 3) '(5)))
  (define/public (enqueue i)
    (cond [(empty? (field front))                          [2pt]
           (queue% (list i) empty)]
          [else
           (queue% (field front) (cons i (field back)))])) [2pt]
  ;; get the first element
  ;;  -> X
  ;; assumes this queue is non-empty
  ;; uses the invariant
  (check-expect (q . head) 1)                              [1pt]
  (define/public (head)                                    
    (first (field front)))
  ;; drop the first element
  ;;  -> [Queue X]
  ;; assumes this queue is non-empty
  (check-expect (eq . enqueue 1 . dequeue) eq)             [1pt]
  (check-expect (q . enqueue 5 . dequeue) (queue% '(2 3) '(5)))
  (define/public (dequeue)
    (cond 
      ;; maintain the invariant -- don't let `front' be empty
      [(empty? (rest (field front)))                       [3pt]
       (queue% (reverse (field back)) empty)]
      ;; otherwise, simple
      [else (queue% (rest (field front)) (field back))]))  [2pt]
  ;; is this queue empty?
  ;; emp? : -> Boolean
  ;; uses the invariant
  (check-expect (q . emp?) false)                          [1pt]
  (check-expect (eq . emp?) true)
  (define/public (emp?)
    (empty? (field front)))

;; Part 2:

;; Examples:                                               [1pt]
(queue% (list 1) (list 6)) vs (queue% (list 1 6) empty)
(queue% (list 1 8 12) (list 6)) vs (queue% (list 1 8) (list 12 6))

  ;; convert the queue to a list                           [1pt]
  ;; -> [Listof X] 
  ;; turn examples above into tests:                       [1pt]
  (check-expect ((queue% (list 1) (list 6)) . to-list)
		((queue% (list 1 6) empty) . to-list))
  (check-expect ((queue% (list 1 8 12) (list 6)) . to-list)
		((queue% (list 1 8) (list 12 6)) . to-list))
  (check-expect (q . to-list) '(1 2 3))                    
  (check-expect (q . enqueue 5 . to-list) '(1 2 3 5))   
  (check-expect (q . enqueue 5 . dequeue . to-list) '(2 3 5))
  (define/public (to-list)                                 [1pt]
    (append (field front)
            (reverse (field back)))))

(define q (queue% '(1 2 3) empty))
(define eq (queue% empty empty))

;; Part 3:                                                 [2pt]
;; several good possibilities (others are possible)
(constructor (f b)
  (fields (append f (reverse b)) empty))

(constructor (f b)
  (cond [(empty? f) (fields (reverse b) empty)]
	[else (fields f b)]))

(constructor (f b)
  (cond [(and (empty? f) (empty? b)) (fields f b)]
	[(empty? f) (fields (reverse b) empty)]
	[else (fields f b)]))

\end{verbatim}
\end{solution}
\end{problem}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{15}
%
Here is a simple interface and implementation for dictionaries that
associate natural numbers to strings.

\begin{verbatim}
;; A Dict is one of:
;;  - (ld-empty%)
;;  - (ld-cons% Nat String Dict)
;; implements:
;;
;; has-key? : Nat -> Boolean
;; Does this dict. have the given key?
;;
;; lookup : Nat -> String
;; Produce the value associated with the given key in this dict.
;; Assume: the key exists in this dict.
;;
;; set : Nat String -> Dict
;; Associate the given key to the given value in this dict.

(define-class ld-empty%
  (define/public (has-key? k) false)

  (define/public (set k v)
    (ld-cons% k v this)))

(define-class ld-cons%
  (fields key val rest)

  (define/public (has-key? k)
    (cond [(= (field key) k) true]
          [else ((field rest) . has-key? k)]))

  (define/public (lookup k)
    (cond [(= (field key) k) (field val)]
          [else ((field rest) . lookup k)]))

  (define/public (set k v)
    (ld-cons% k v this)))
\end{verbatim}

The dictionary data structure has some important properties, one of
which is that if we associate a value with a key and then look up that
key, we expect to get back the value we associated.  For example, for
any given dictionary, if we associate \code{1} with \code{"Fred"},
then look up \code{1}, we should get \code{"Fred"}.  More generally,
we expect this to be true for \emph{any} key-value pair, not just
\code{1} and \code{"Fred"}.

\begin{enumerate}
\item Codify the general ``set/lookup'' property, described above, as
  a predicate.  Write a successful test in terms of that predicate.
\end{enumerate}

Now consider a generalization of the ``set/lookup'' property which
says that if we set \emph{two} keys to \emph{two} values then look
each of them up, we should get back the original values.  For example, for
any given dictionary, if we associate \code{1} with \code{"Fred"} and
\code{2} with \code{"Wilma"}; then looking up \code{1} will produce
\code{"Fred"} and looking up \code{2} will produce \code{"Wilma\"}.
More generally, we can state this as a property for any two key-value
pairs. 

\begin{enumerate}
\setcounter{enumi}{1}
\item Codify the general ``double-set/lookup'' property as a
  predicate.  Write a successful test in terms of that predicate.

\item Does this property hold for all dictionaries and keys-value
  pairs?  If so, why?  If not, write a counter-example, i.e.~write a
  failing test in terms of the predicate you gave in part 2.
\end{enumerate}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi
\end{problem}

\begin{solution}
\begin{verbatim}
;; Part 1 
;; Dict Nat String -> Boolean            [4pt]
(define (set/lookup d k v)
  (string=? (d . set k v . lookup k) v))

;; [2pt]
(check-expect (set/lookup (ld-empty%) 1 "Fred") true)

;; Part 2
;; Dict Nat String Nat String -> Boolean   [4pt]
(define (double-set/lookup d k1 v1 k2 v2)
  (and (string=? (d . set k1 v1 . set k2 v2 . lookup k1) v1)
       (string=? (d . set k1 v1 . set k2 v2 . lookup k2) v2)))

;; [2pt]
(check-expect (double-set/lookup (ld-empty%) 1 "Fred" 2 "Wilma") true)

;; Part 3  [3pt]
;; Counter-example:
(check-expect (double-set/lookup (ld-empty%) 1 "Fred" 1 "Wilma") true)
\end{verbatim}
\end{solution}

\end{document}


