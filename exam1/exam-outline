

* Numeric Ranges (Sam)

 - Design and develop a representation for half-open intervals of REAL
   numbers (lo,hi]
 - " the methods `in-range?' and `overlap?'
 - add a new variant for half-open intervals in the other direction
 - add a union method to both variants.  You will need to adjust your
   data defintion.  

* Shapes and Bounding Boxes (DVH)

 - We give them class defs for Shapes (Circle, Rectangle)
 - They develop a `bounding-box-area' method
 - Then develop a superclass and abstract the b-b-a method.
   You may need to extend the Shape Interface
 - Add a new variant (Square), which should support all the method of
   the interface.

* Objects as functions (DVH)
  - We give them the [IFun X Y] interface, with method apply : X -> Y
  - they implement the general unary wrapper
  - instantiate the wrapper for add1 and sub1
  - Then develop the compose method : [IFun Y Z] -> [IFun X Z]
  - example: add1 o sub1 = id

* Queue with invariants (Sam)
  - We describe the queue built from two lists, with the spec for
  enq/deq/head.
  - They implement enq/deq/head, maintaingin/exploiting the invariant
  - they give example of two reps of the same data, implement to-list
  which canonicalizes
  - implement constructor which takes two lists, maintains invariant,
  errors if both empty

* Dictionaries and properties (DVH)
  - We give a dictionary interface/impl
  - state informally the insert/lookup property
  - they write a predicate which checks the property, and tests that
  use the predicate
  - state informally the two-insert/lookup-both property
  - write a predicate
  - is this generally true?  If so, why? If not, give a
  counterexample.  