% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\ifrubric
\centerline{\Large CSU2510H Exam 1 Rubric -- Spring 2011}

\else
\centerline{\Large CSU2510H Exam 1 -- Spring 2011}

\vspace{0.5cm}

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{7cm}\sloppy
\begin{itemize}
\item Write down the answers in the space provided.

\item You may use the usual primitives and expression forms, including those
suggested in hints; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} in place of
  {\tt (check-expect {\slshape c e})} to save time writing. 
  You may also write the Greek letter $\lambda$ 
  instead of \code{lambda}, to save writing.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can be thinking
about the harder problems in background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & ??\\ \hline
2 & & ??\\ \hline
3 & & ??\\ \hline
4 & & ??\\ \hline
5 & & ??\\ \hline
%Extra & & 6\\ \hline
{\bf Total} & & 62 \\ \hline
{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \noindent
% {\bf Home on the Range}

% Come up with funny story here.



% \newpage
\begin{problem}\pts{16}
\noindent 

A \emph{range} represents a set of numbers between two endpoints.  To
start with, you only need to consider ranges that \emph{include} the
smaller endpoint, and \emph{exclude} the larger endpoint---such ranges
are called \emph{half-open}.  For example, the range $[3,4.7)$
includes all of the numbers between $3$ and $4.7$, including $3$ but
\emph{not} including $4.7$. So $4$ and $3.0000001$ are both in the
range, but $5$ is not.  In the notation used here, the $[$ means
include, and the $)$ means exclude.

% \begin{verbatim}
%     ;; A Range is (new range% Number Number)

%     ;; Interp: represents the range between `lo' and `hi'
%     ;;         including `lo', but *not* including `hi'

%     ;; and implements:

%     ;; - in-range? : Number -> Boolean
%     ;; determine if the given number is in this range
% \end{verbatim}

\smallskip

\noindent
\begin{itemize}
\item[A)\;] Design a representation for ranges, along with the
  \texttt{in-range?} method, which determines if a number is in the
  range.  For example, the range $[3,7.2)$ includes the numbers $3$
  and $5.0137$, but not the numbers $-17$ or $7.2$.

\item[B)\;] Extend the data definition and implementation of ranges to
  include ranges that \emph{exclude} the low end of the range and
  \emph{include} the high end.  These ranges are written $(lo,hi]$.  

\item[C)\;] Add a \texttt{union} method to the interface for ranges,
  and to all of the classes that implement the interface for ranges.
  This method consumes a second range, and produces a new range including
  everything that was in \emph{either} range. 

  You will likely need to extend your data defintion for ranges to
  support this method.  

\end{itemize}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
;; ** A)
;; emails-from : [Listof Email] Symbol -> [Listof Email]    [1pt]
;; Return the emails in the list from the given address     [1pt]
(define (emails-from loe addr)
  (cond [(empty? loe) empty]                     ;  [1pt]
        [(symbol=? addr (email-from (first loe)));  [1pt]
         (cons (first loe)
               (emails-from (rest loe) addr))]   ;  [1pt]
        [else
         (emails-from (rest loe) addr)]))        ;  [1pt]

(define e1 (make-email 'teacher@neu.com "Hello" "That's it"))
(define e2 (make-email 'bob@builder.com "Bonjour" "C'est tout"))

(check-expect (emails-from empty 'bob@builder.com) empty)
(check-expect (emails-from (list e1) 'bob@builder.com)
              empty)
(check-expect (emails-from (list e1 e2) 'bob@builder.com)
              (list e2))

;; ** B)
;; subjects : [Listof Email] -> [Listof String]   [1pt]
;; Return a list of all the Email subjects        [1pt]
(define (subjects loe)
  (cond [(empty? loe) empty]                   ;  [1pt]
        [else
         (cons (email-subject (first loe))     ;  [1pt]
               (subjects (rest loe)))]))       ;  [1pt]

(check-expect (subjects empty) empty)
(check-expect (subjects (list e1))
              (list "Hello"))
(check-expect (subjects (list e1 e2))
              (list "Hello" "Bonjour"))

;; ** C)
;; total-size : [Listof Email] -> Number               [1pt]
;; Return the total size of the email bodies           [1pt]
(define (total-size loe)
  (cond [(empty? loe) 0]                            ;  [1pt]
        [else
         (+ (string-length (email-body (first loe)));  [1pt]
            (total-size (rest loe)))]))             ;  [1pt]

(check-expect (total-size empty) 0)
(check-expect (total-size (list e1)) 9)
(check-expect (total-size (list e1 e2)) 19)
\end{verbatim}
\end{solution}
\end{problem}
\ifrubric\bigskip\else
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{??}

Here are data, class, and interface definitions for Shapes:
\begin{verbatim}
;; A Shape is one of:
;; - (rect% Number Number)
;; - (circ% Number)
;; implements:
;; Compute the area of the smallest bounding box for this shape.
;; bounding-box-area : -> Number

(define-class rect%
  (fields width height))

(define-class circ%
  (fields radius))
\end{verbatim}
%
Here are some examples of how \code{bounding-box-area} should work:
\begin{verbatim}
(check-expect ((rect% 3 4) . bounding-box-area) 12)
(check-expect ((circ% 1.5) . bounding-box-area)  9)
\end{verbatim}


\begin{enumerate}
\item Develop the \code{bounding-box-area} method for the
  \code{rect\%} and \code{circ\%} class.

\item Develop a super class of \code{rect\%} and \code{circ\%} and
  lift the \code{bounding-box-area} method to the superclass.  Extend
  the shape interface as needed, but implement any methods you add.

\item Develop a new variant of a Shape, a Square, which should support
  all of the methods of the interface.
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; Part 1
(define-class rect% 
  (fields width height)
  (define/public (bounding-box-area)
    (* (field width) (field height))))
  
(define-class circ% 
  (fields radius)
  (define/public (bounding-box-area)
    (sqr (* 2 (field radius)))))

;; Part 2

;; implements:
;; width : -> Number
;; height : -> Number
;; Compute the {width,height} of this shape.

(define-class shape% 
  (define/public (bounding-box-area)
    (* (this . width) (this . height))))

(define-class rect% 
  (super shape%)
  (fields width height))
  
(define-class circ% 
  (super shape%)
  (fields radius)
  (define/public (width)
    (* 2 (field radius)))
  (define/public (height)
    (width)))

;; Part 3
    
(define-class square%
  (super shape%)
  (fields width)
  (define/public (height)
    (width)))

(check-expect ((square% 5) . bounding-box-area) 25)
\end{verbatim}
\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{??}

One perspective that unifies the paradigms of programming with
functions and programming with objects is to view a ``function'' as an
object that understands a method called \code{apply}.  With that in
mind, we can define an interface for functions-as-objects:

\begin{verbatim}
;; A [IFun X Y] implements:
;; apply : X -> Y
;; Apply this function to the given input.
\end{verbatim}

Here we are representing a \code{X -> Y} function as an object that
has an \code{apply} method that consumes an \code{X} and produces a
\code{Y}.

\begin{enumerate}
\item Design a class that wraps a real function with contract \code{(X
  -> Y)} to implement \code{[IFun X Y]}.

\item Using your wrapper class, construct the objects representing the
  ``add 1'' function and ``sub 1'' function.

\item Another useful operations on functions is composition.  Here is
  the interface for a \code{compose} method that composes two functions
  represented as objects:

\begin{verbatim}
;; [IFun X Y] also implements:
;; compose : [IFun Y Z] -> [IFun X Z]
;; Produce a function that applies this function to its input, 
;; then applies the given function to that result.
\end{verbatim}

For example, if \code{addone} and \code{subone} refer to the objects
you constructed in part 2, the following check should succeed:

\begin{verbatim}
(check-expect ((addone . compose subone) . apply 5) 5)
(check-expect ((addone . compose addone) . apply 5) 7)
\end{verbatim}

Implement the \code{compose} method for your wrapper class.
\end{enumerate}

\begin{solution}

\begin{verbatim}
;; Part 1
(define-class fun%
  (fields f)
  (define/public (apply x)
    ((field f) x)))

;; Part 2
(define addone (fun% add1))
(define subone (fun% sub1))

;; Part 3
(define-class fun%
  (fields f)
  (define/public (compose g)
    (fun% (lambda (x)
            (g . apply (apply x))))))
\end{verbatim}

\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{13}
 
  The programs of the previous problem, if developed with the design
  recipe for structural recursion, should follow patterns abstracted
  by one of the loop functions.
  For each of the programs you wrote, re-write it using a loop function.
  In each case, \emph{one} loop function should suffice.

Since you have already written the contract and purpose statement
(right? it is Google policy, after all) you \textit{only} need to
write the function definitions.

\begin{itemize}
\item[A)\;] Write \texttt{emails-from} using a loop function.

\item[B)\;] Write \texttt{subjects} using a loop function.

\item[C)\;] Write \texttt{total-size} using a loop function.
\end{itemize}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
;; ** A)
(define (emails-from loe addr)
  (filter                             ; [1pt]
   (lambda (e)                        ; [1pts]
     (symbol=? (email-from e) addr))  ; [2pts]
   loe))

(define e1 (make-email 'teacher@neu.com "Hello" "That's it"))
(define e2 (make-email 'bob@builder.com "Bonjour" "C'est tout"))

;; ** B)
(define (subjects loe)
  (map                   ; [1pt]
   email-subject         ; [2pt]
   loe))

;; ** C)
(define (total-size loe)
  (foldr                 ; [1pt]
   (lambda (e tot)       ; [2pt]
     (+ (string-length   ; [2pt]
         (email-body e)) tot))
   0                     ; [1pt]
   loe))
\end{verbatim}
\end{solution}
\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{8}

  Design a function, \texttt{weaver}, that weaves two lists into a
  single list by alternating their elements.  Make sure you give it a
  general contract.

\bigskip

\noindent Here are some tests/examples to further explain:

\begin{verbatim}
    (check-expect (weaver empty (list 1)) (list 1))
    (check-expect (weaver (list "Hi" "Lo") empty) (list "Hi" "Lo"))
    (check-expect (weaver (list 1 2) (list 3 4))
                  (list 1 3 2 4))
    (check-expect (weaver (list 'R 'C 'R) (list 'A 'E))
                  (list 'R 'A 'C 'E 'R))
\end{verbatim}

\begin{solution}
\begin{verbatim}
;; weaver : [Listof X] [Listof X] -> [Listof X]     [1pt]
;; Weave two lists in alternating order             [1pt]
(define (weaver l1 l2)
  (cond [(empty? l1) l2]                            [1pt]
        [(empty? l2) l1]                            [1pt]
        [else (cons (first l1)                      [2pts]
                    (cons (first l2)
                          (weaver (rest l1)
                                  (rest l2))))]))   [2pts]

;; Alternatively...
(define (weaver l1 l2)
  (cond [(empty? l1) l2]
        [else (cons (first l1)
                    (weaver l2 (rest l1)))]))
\end{verbatim}
\end{solution}

\end{problem}

\ifrubric\bigskip\else
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{6}

The Northeastern University Registrar is instituting a new
course registration system, in which each student will wait in a
``Virtual Line'' until every student ahead of them has registered.  In
order to provide maximal waiting efficenciy, you have been tasked with
implementing a \emph{queue} data structure, designed as follows.  

Each queue will be represented using two lists, the \emph{front} and
\emph{back} of the queue.  All of the elements in the front come
before the elements in the back, but the back is represented in
\emph{reverse order}.  

Queues support four basic operations:
\begin{itemize}
\item \texttt{head} produces the first element in the queue,
\item \texttt{dequeue} produces a queue without the first element,
\item \texttt{enqueue} adds a new element on to the \emph{end} of the
  queue,
\item \texttt{emp?} determines if the queue is empty.
\end{itemize}
The \texttt{head} and \texttt{dequeue} operations require that the
queue be non-empty when they are used---these operations do not need
to check for an empty queue.

Further, the Registrar's office has just learned about invariants, and
insists on maintaining the following invariant about all of their
queues:  

\begin{quote}
  {\it if the front of the queue is empty, the whole queue must also be empty.}
\end{quote} 

\noindent
The Registrar's office has given you three tasks to prepare their
Virtual Line for its launch later this semester:

\begin{enumerate}
\item Design and implement the queue data structure to the Registrar's
  specifcations.  You must maintain the invariant stated above, and
  you should take advantage of the invariant when implementing the
  operations.
\item Unfortunately, when testing the queue, the Registrar has
  discovered that some queues with the same elementes in the same
  order can be represented in multiple ways.  Give two examples of
  this, and implement a \texttt{to-list} operation which produces the
  elements in a list, in the appropriate order.  In your tests, you
  should show how this addresses the problem.
\item The Registrar has a problem with careless data entry.  Design
  and implement a constructor for queues which, given two input lists
  of elements, ensures that the invariant is maintained.  
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; invariant: front is empty IFF queue is empty
;; A [Queue X] is (queue% [Listof X] [Listof X])

(define-class queue%
  (fields front back)
  ;; Add element to the back
  ;; X -> [Queue X]
  ;; add it to the front IFF the front is empty
  ;; (otherwise invariant is violated)
  (define/public (enqueue i)
    (cond [(empty? (field front))
           (queue% (list i) empty)]
          [else
           (queue% (field front) (cons i (field back)))]))
  ;; get the first element
  ;;  -> X
  ;; assumes this queue is non-empty
  ;; uses the invariant
  (define/public (head)
    (first (field front)))
  ;; drop the first element
  ;;  -> [Queue X]
  ;; assumes this queue is non-empty
  (define/public (dequeue)
    (cond 
      ;; maintain the invariant -- don't let `front' be empty
      [(empty? (rest (field front)))
       (queue% (reverse (field back)) empty)]
      ;; otherwise, simple
      [else (queue% (rest (field front)) (field back))]))
  ;; is this queue empty?
  ;; emp? : -> Boolean
  ;; uses the invariant
  (define/public (emp?)
    (empty? (field front)))
  ;; convert the queue to a list
  ;; -> [Listof X] 
  (define/public (to-list)
    (append (field front)
            (reverse (field back)))))

(define q (queue% '(1 2 3) empty))
(define eq (queue% empty empty))

(check-expect (q . emp?) false)
(check-expect (q . head) 1)
(check-expect (eq . emp?) true)
(check-expect (eq . enqueue 1) (queue% '(1) '()))
(check-expect (eq . enqueue 1 . dequeue) eq)
(check-expect (q . enqueue 5) (queue% '(1 2 3) '(5)))
(check-expect (q . enqueue 5 . dequeue) (queue% '(2 3) '(5)))

(check-expect (q . to-list) '(1 2 3))
(check-expect (q . enqueue 5 . to-list) '(1 2 3 5))
(check-expect (q . enqueue 5 . dequeue . to-list) '(2 3 5))
\end{verbatim}
\end{solution}
\end{problem}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{??}

[Dictionary problem]

\end{problem}

\end{document}


