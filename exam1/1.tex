% You must \input this file into a file the has previously
% defined the \ifrubric conditional.

\documentclass[12pt]{article}                   % -*- latex -*-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{./exam}
\usepackage{type1cm} % We are using scalable fonts. Really.
\usepackage{alltt,times,comment,amsmath}
\usepackage{ct} % tight CM font for \tt
\newexercise{exercise}{Exercise}[subsection]

\makeatletter
\newcommand{\ie}{\mbox{\emph{i.e.}}}    % \mbox keeps the last period from
\newcommand{\Ie}{\mbox{\emph{I.e.}}}    % looking like an end-of-sentence.
\newcommand{\etc}{\emph{etc.}}

\newcommand{\itum}[1]{\item{\bf #1}\\*}

\newcommand{\var}[1]{\textrm{\textit{#1}}}

\newenvironment{inset}
 {\bgroup\parskip=1ex plus 1ex\begin{list}{}%
        {\topsep=0pt\rightmargin\leftmargin}%
        \item[]}%
 {\end{list}\leavevmode\egroup\global\@ignoretrue}

\newenvironment{insetverb}%
  {\begin{inset}\begin{verbatim}}%
  {\end{verbatim}\end{end}}%

\def\pts#1{\marginpar{\footnotesize \raggedright  \fbox{#1 {\sc Points}}}}
%\def\pts#1{\relax}

\ifrubric
\newenvironment{solution}{}{}
\else
\excludecomment{solution}
\fi
\newexercise{problem}{Problem}

\newcommand\code[1]{\texttt{#1}}

% Works in math mode; all special chars remain special; cheaper than \cd.
% Will not be correct size in super and subscripts, though.
\newcommand{\ex}[1]{\mbox{\ttt #1}} 
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\vspace*{-1.5cm}
\ifrubric
\centerline{\Large CSU2510H Exam 1 Rubric -- Spring 2011}

\else
\centerline{\Large CSU2510H Exam 1 -- Spring 2011}

\vspace{0.5cm}

\begin{center}
\begin{tabular}{l@{\qquad}l}
Name:                        & \rule{174pt}{1pt} \\[.5cm]
Student Id (last 4 digits):  & \rule{174pt}{1pt} \\[.5cm]
%Section (morning, honors or afternoon):           & \rule{174pt}{1pt} \\[.5cm]
\end{tabular}
\end{center}

\noindent\begin{minipage}{7cm}\sloppy
\begin{itemize}
\item Write down the answers in the space provided.

\item You may use the usual primitives and expression forms of any of
  the \code{class} languages; for everything else, define it.

\item You may write {\tt {\slshape c} $\rightarrow$ {\slshape e}} for
  {\tt (check-expect {\slshape c e})} and $\lambda$ for
  \code{lambda} to save time writing.

\item To add a method to an existing class definition, you
  may write just the method and indicate the appropriate class name
  rather than re-write the entire class definition.

\item If an interface is given to you, you do not need to repeat the
  contract and purpose statements in your implementations.  Likewise,
  you do not need to repeat any test cases given to you, but you
  should add tests wherever appropriate.

%% DVH: This info is already in the table.
% \item You may obtain a maximum of 55 points: 50 for the first six
% problems; and five extra-credit points for the final problem.

\item Some basic test taking advice: Before you start answering
any problems, read \emph{every} problem, so your brain can be thinking
about the harder problems in background while you knock off the easy ones.
\end{itemize}

\bigskip

\emph{Good luck!}
\end{minipage}\hfil\begin{minipage}[t]{6cm}
\rule{1cm}{0pt}\begin{tabular}{|c|l|@{/}r|}
\hline
{\bf Problem} & Points & out of \\ \hline
1 & & ??\\ \hline
2 & & ??\\ \hline
3 & & ??\\ \hline
4 & & ??\\ \hline
5 & & ??\\ \hline
%Extra & & 6\\ \hline
{\bf Total} & & 62 \\ \hline
{\bf Base}  & \multicolumn{2}{l|}{{\bf 56}} \\ \hline
\end{tabular}
\end{minipage}

\vfill\thispagestyle{empty}
\newpage

\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \noindent
% {\bf Home on the Range}

% Come up with funny story here.



% \newpage
\begin{problem}\pts{16}

A \emph{range} represents a set of numbers between two endpoints.  To
start with, you only need to consider ranges that \emph{include} the
smaller endpoint and \emph{exclude} the larger endpoint---such ranges
are called \emph{half-open}.  For example, the range $[3,4.7)$
includes all of the numbers between $3$ and $4.7$, including $3$ but
\emph{not} including $4.7$. So $4$ and $3.0000001$ are both in the
range, but $5$ is not.  In the notation used here, the $[$ means
include, and the $)$ means exclude.

% \begin{verbatim}
%     ;; A Range is (new range% Number Number)

%     ;; Interp: represents the range between `lo' and `hi'
%     ;;         including `lo', but *not* including `hi'

%     ;; and implements:

%     ;; - in-range? : Number -> Boolean
%     ;; determine if the given number is in this range
% \end{verbatim}

\smallskip

\noindent
\begin{enumerate}
\item Design a representation for ranges and implement the
  \texttt{in-range?} method, which determines if a number is in the
  range.  For example, the range $[3,7.2)$ includes the numbers $3$
  and $5.0137$, but not the numbers $-17$ or $7.2$.

\item Extend the data definition and implementation of ranges to
  represent ranges that \emph{exclude} the low end of the range and
  \emph{include} the high end, written $(lo,hi]$.  

\item Add a \texttt{union} method to the interface for ranges and
  implement it in all range classes.  This method should consume a
  range and produces a new range that includes all the numbers in this
  range \emph{and} all the numbers in the given range.

  You may extend your data definition for ranges to
  support this method.

  You may apply the abstraction recipe, but you are not required to do
  so; you will not be marked down for duplicated code on this problem.
\end{enumerate}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\begin{solution}
\begin{verbatim}
;; ** A)
;; emails-from : [Listof Email] Symbol -> [Listof Email]    [1pt]
;; Return the emails in the list from the given address     [1pt]
(define (emails-from loe addr)
  (cond [(empty? loe) empty]                     ;  [1pt]
        [(symbol=? addr (email-from (first loe)));  [1pt]
         (cons (first loe)
               (emails-from (rest loe) addr))]   ;  [1pt]
        [else
         (emails-from (rest loe) addr)]))        ;  [1pt]

(define e1 (make-email 'teacher@neu.com "Hello" "That's it"))
(define e2 (make-email 'bob@builder.com "Bonjour" "C'est tout"))

(check-expect (emails-from empty 'bob@builder.com) empty)
(check-expect (emails-from (list e1) 'bob@builder.com)
              empty)
(check-expect (emails-from (list e1 e2) 'bob@builder.com)
              (list e2))

;; ** B)
;; subjects : [Listof Email] -> [Listof String]   [1pt]
;; Return a list of all the Email subjects        [1pt]
(define (subjects loe)
  (cond [(empty? loe) empty]                   ;  [1pt]
        [else
         (cons (email-subject (first loe))     ;  [1pt]
               (subjects (rest loe)))]))       ;  [1pt]

(check-expect (subjects empty) empty)
(check-expect (subjects (list e1))
              (list "Hello"))
(check-expect (subjects (list e1 e2))
              (list "Hello" "Bonjour"))

;; ** C)
;; total-size : [Listof Email] -> Number               [1pt]
;; Return the total size of the email bodies           [1pt]
(define (total-size loe)
  (cond [(empty? loe) 0]                            ;  [1pt]
        [else
         (+ (string-length (email-body (first loe)));  [1pt]
            (total-size (rest loe)))]))             ;  [1pt]

(check-expect (total-size empty) 0)
(check-expect (total-size (list e1)) 9)
(check-expect (total-size (list e1 e2)) 19)
\end{verbatim}
\end{solution}
\end{problem}
\ifrubric\bigskip\else
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{??}

Here are data, class, and interface definitions for Shapes:
\begin{verbatim}
;; A Shape is one of:
;; - (rect% Number Number)
;; - (circ% Number)
;; implements:
;; bba : -> Number     (short for "bounding-box-area")
;; Compute the area of the smallest bounding box for this shape.

(define-class rect%
  (fields width height))

(define-class circ%
  (fields radius))
\end{verbatim}
%
Here are some examples of how \code{bounding-box-area} should work:
\begin{verbatim}
(check-expect ((rect% 3 4) . bba) 12)
(check-expect ((circ% 1.5) . bba)  9)
\end{verbatim}


\begin{enumerate}
\item Design the \code{bba} method for the
  \code{rect\%} and \code{circ\%} class.

\item Design a super class of \code{rect\%} and \code{circ\%} and
  lift the \code{bba} method to the super class.  Extend
  the shape interface as needed, but implement any methods you add.

\item Design a new variant of a Shape, Square, which should support
  all of the methods of the interface.
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; Part 1
(define-class rect% 
  (fields width height)
  (define/public (bounding-box-area)
    (* (field width) (field height))))
  
(define-class circ% 
  (fields radius)
  (define/public (bounding-box-area)
    (sqr (* 2 (field radius)))))

;; Part 2

;; implements:
;; width : -> Number
;; height : -> Number
;; Compute the {width,height} of this shape.

(define-class shape% 
  (define/public (bounding-box-area)
    (* (this . width) (this . height))))

(define-class rect% 
  (super shape%)
  (fields width height))
  
(define-class circ% 
  (super shape%)
  (fields radius)
  (define/public (width)
    (* 2 (field radius)))
  (define/public (height)
    (width)))

;; Part 3
    
(define-class square%
  (super shape%)
  (fields width)
  (define/public (height)
    (width)))

(check-expect ((square% 5) . bounding-box-area) 25)
\end{verbatim}
\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}\pts{??}

One perspective that unifies the paradigms of programming with
functions and programming with objects is to view a ``function'' as an
object that understands a method called \code{apply}.  With that in
mind, we can define an interface for functions-as-objects:

\begin{verbatim}
;; A [IFun X Y] implements:
;; apply : X -> Y
;; Apply this function to the given input.
\end{verbatim}

Here we are representing a \code{X -> Y} function as an object that
has an \code{apply} method that consumes an \code{X} and produces a
\code{Y}.

\begin{enumerate}
\item Design a class that wraps a real function with contract \code{(X
  -> Y)} to implement \code{[IFun X Y]}.

\item Using your wrapper class, construct the objects representing the
  ``add 1'' function and ``sub 1'' function.

\item Another useful operations on functions is composition.  Here is
  the interface for a \code{compose} method that composes two functions
  represented as objects:

\begin{verbatim}
;; [IFun X Y] also implements:
;; compose : [IFun Y Z] -> [IFun X Z]
;; Produce a function that applies this function to its input, 
;; then applies the given function to that result.
\end{verbatim}

For example, if \code{addone} and \code{subone} refer to the objects
you constructed in part 2, the following check should succeed:

\begin{verbatim}
(check-expect ((addone . compose subone) . apply 5) 5)
(check-expect ((addone . compose addone) . apply 5) 7)
\end{verbatim}

Implement the \code{compose} method for your wrapper class.
\end{enumerate}

\begin{solution}

\begin{verbatim}
;; Part 1
(define-class fun%
  (fields f)
  (define/public (apply x)
    ((field f) x)))

;; Part 2
(define addone (fun% add1))
(define subone (fun% sub1))

;; Part 3
(define-class fun%
  (fields f)
  (define/public (compose g)
    (fun% (lambda (x)
            (g . apply (apply x))))))
\end{verbatim}

\end{solution}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

\end{problem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{6}

The Northeastern University Registrar is instituting a new course
registration system, in which each student will wait in a ``Virtual
Line'' until every student ahead of them has registered.  A simple way
to represent a line (also known as a \emph{queue}) is by using a list.
But this representation makes it slow to add somebody to the end of
the line (or to take somebody off the front of the line, depending on
whether the front of the list represents the front or rear of the
line).  

In order to provide maximal waiting efficiency, you have been tasked
with implementing a representation that uses \emph{two} lists!  The
key idea of this fancy representation is that one list will represent
some portion of the front of the line, while the other will represent
the remainder of the line \emph{in reverse order}.  So if you're the
first element of the first list, you are at the head of the line.  On
the other hand, if you're the first element of the second list, you
are the very last person in line.

Here is the interface for queues:
\begin{verbatim}
;; A [IQ X] implements:
;;
;; head : -> X
;; Produce the element at the head of this queue.
;; Assume: this queue is not empty.
;;
;; deq : -> [IQ X]      (Short for "dequeue")
;; Produces a queue without the first element.
;; Assume: this queue is not empty.
;;
;; enq : X -> [IQ X]    (Short for "enqueue")
;; Add given element to the END of this queue.
;;
;; emp? : -> Boolean
;; Is this queue empty?
\end{verbatim}

The \code{head} and \code{deq} operations require that the queue be
non-empty when they are used, but this can be assumed and these
operations do not need to check for an empty queue.

Further, the Registrar's office has just learned about
\emph{invariants}, and insists on maintaining the following invariant
about all of their queues:

\begin{quote}
  {\it if the front of the queue is empty, the whole queue must also be empty.}
\end{quote} 

\noindent
The Registrar's office has given you three tasks to prepare their
Virtual Line for its launch later this semester:

\begin{enumerate}
\item Design an implementation of the queue data structure to the Registrar's
  specifications.  You must maintain the invariant stated above, and
  you should take advantage of the invariant when implementing the
  operations.
\item Unfortunately, when testing the queue, the Registrar has
  discovered that some queues with the same elements in the same order
  can be represented in multiple ways.  Give an example of two
  different representations of the same queue.  Implement a
  \code{to-list} operation which produces a list of elements going in
  order from the front of the rear of the queue. In your tests, you
  should show how this addresses the problem.
\item The Registrar has a problem with careless data entry.  Design
  and implement a constructor for queues which, given two input lists
  of elements, ensures that the invariant is maintained.  
\end{enumerate}

\begin{solution}
\begin{verbatim}
;; invariant: front is empty IFF queue is empty
;; A [Queue X] is (queue% [Listof X] [Listof X])

(define-class queue%
  (fields front back)
  ;; Add element to the back
  ;; X -> [Queue X]
  ;; add it to the front IFF the front is empty
  ;; (otherwise invariant is violated)
  (define/public (enqueue i)
    (cond [(empty? (field front))
           (queue% (list i) empty)]
          [else
           (queue% (field front) (cons i (field back)))]))
  ;; get the first element
  ;;  -> X
  ;; assumes this queue is non-empty
  ;; uses the invariant
  (define/public (head)
    (first (field front)))
  ;; drop the first element
  ;;  -> [Queue X]
  ;; assumes this queue is non-empty
  (define/public (dequeue)
    (cond 
      ;; maintain the invariant -- don't let `front' be empty
      [(empty? (rest (field front)))
       (queue% (reverse (field back)) empty)]
      ;; otherwise, simple
      [else (queue% (rest (field front)) (field back))]))
  ;; is this queue empty?
  ;; emp? : -> Boolean
  ;; uses the invariant
  (define/public (emp?)
    (empty? (field front)))
  ;; convert the queue to a list
  ;; -> [Listof X] 
  (define/public (to-list)
    (append (field front)
            (reverse (field back)))))

(define q (queue% '(1 2 3) empty))
(define eq (queue% empty empty))

(check-expect (q . emp?) false)
(check-expect (q . head) 1)
(check-expect (eq . emp?) true)
(check-expect (eq . enqueue 1) (queue% '(1) '()))
(check-expect (eq . enqueue 1 . dequeue) eq)
(check-expect (q . enqueue 5) (queue% '(1 2 3) '(5)))
(check-expect (q . enqueue 5 . dequeue) (queue% '(2 3) '(5)))

(check-expect (q . to-list) '(1 2 3))
(check-expect (q . enqueue 5 . to-list) '(1 2 3 5))
(check-expect (q . enqueue 5 . dequeue . to-list) '(2 3 5))
\end{verbatim}
\end{solution}
\end{problem}

\newpage
\ifrubric\else
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem} \pts{??}
%
Here is a simple interface and implementation for dictionaries that
associate natural numbers to strings.

\begin{verbatim}
;; A Dict is one of:
;;  - (ld-empty%)
;;  - (ld-cons% Nat String Dict)
;; implements:
;;
;; has-key? : Nat -> Boolean
;; Does this dict. have the given key?
;;
;; lookup : Nat -> String
;; Produce the value associated with the given key in this dict.
;; Assume: the key exists in this dict.
;;
;; set : Nat String -> Dict
;; Associate the given key to the given value in this dict.

(define-class ld-empty%
  (define/public (has-key? k) false)

  (define/public (set k v)
    (ld-cons% k v this)))

(define-class ld-cons%
  (fields key val rest)

  (define/public (has-key? k)
    (cond [(= (field key) k) true]
          [else ((field rest) . has-key? k)]))

  (define/public (lookup k)
    (cond [(= (field key) k) (field val)]
          [else ((field rest) . lookup k)]))

  (define/public (set k v)
    (ld-cons% k v this)))
\end{verbatim}

The dictionary data structure has some important properties, one of
which is that if we associate a value with a key and then look up that
key, we expect to get back the value we associated.  For example, for
any given dictionary, if we associate \code{1} with \code{"Fred"},
then look up \code{1}, we should get \code{"Fred"}.  More generally,
we expect this to be true for \emph{any} key-value pair, not just
\code{1} and \code{"Fred"}.

\begin{enumerate}
\item Codify the general ``set/lookup'' property, described above, as
  a predicate.  Write a successful test in terms of that predicate.
\end{enumerate}

Now consider a generalization of the ``set/lookup'' property which
says that if we set \emph{two} keys to \emph{two} values then look
each of them up, we should get back the original values.  For example, for
any given dictionary, if we associate \code{1} with \code{"Fred"} and
\code{2} with \code{"Wilma"}; then looking up \code{1} will produce
\code{"Fred"} and looking up \code{2} will produce \code{"Wilma\"}.
More generally, we expect this to be true for any two key-value pairs.

\begin{enumerate}
\setcounter{enumi}{1}
\item Codify the general ``double-set/lookup'' property as a
  predicate.  Write a successful test in terms of that predicate.

\item Does this property hold for all dictionaries and keys-value
  pairs?  If so, why?  If not, write a counter-example, i.e.~write a
  failing test in terms of the predicate you gave in part 2.
\end{enumerate}

\ifrubric\else
\newpage
[Here is some more space for the previous problem.]
\newpage
[Here is some more space for the previous problem.]
\newpage
\fi
\end{problem}

\begin{solution}
\begin{verbatim}
;; Part 1
;; Dict Nat String -> Boolean
(define (set/lookup d k v)
  (string=? (d . set k v . lookup k) v))

(check-expect (set/lookup (ld-empty%) 1 "Fred") true)

;; Part 2
;; Dict Nat String Nat String -> Boolean
(define (double-set/lookup d k1 v1 k2 v2)
  (and (string=? (d . set k1 v1 . set k2 v2 . lookup k1) v1)
       (string=? (d . set k1 v1 . set k2 v2 . lookup k2) v2)))

(check-expect (double-set/lookup (ld-empty%) 1 "Fred" 2 "Wilma") true)

;; Part 3
;; Counter-example:
(check-expect (double-set/lookup (ld-empty%) 1 "Fred" 1 "Wilma") true)
\end{verbatim}
\end{solution}

\end{document}


